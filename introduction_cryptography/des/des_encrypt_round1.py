#!/usr/bin/python3
import argparse
from argparse import RawTextHelpFormatter
from helpers import *


# arguments
parser=argparse.ArgumentParser(
    description='''
    cleartext input can be 64-bit string in 4-digit blocks,
    key k1 is 48-bit string with key input for round 1 after the steps 'PC-1' and transformation
     OR (type "none" for key k1 to use the second option:)
    key is 64-bit string before the steps 'PC-1' and transformation 
    
    All values can also be generated by entering the following options, when asked via stdin:

    all0\t    generate 64 (cleartext) or 48 (key) digits with 0
    all1\t    generate 64 (cleartext) or 48 (key) digits with 1
    generate1 35
          \t    generate 64 or 48 digits with 0, where the 35. position is 1
    generate0 2 14
          \t    generate 64 or 48 digits with 1 where the 2. and 14. position is 0
    ''', formatter_class=RawTextHelpFormatter)
args=parser.parse_args()


# read cleartext modification tables
subf = "conv_tables/"
ip_table = read_table(subf+"ip.txt")
exp_table = read_table(subf+"expansion.txt")
perm_table = read_table(subf+"permutation.txt")
sbox_tables = []
for sbox_number in range(1, 9):
    filename = f"s{sbox_number}.txt"
    sbox_tables.append(read_table(subf+filename))
perm_table = read_table(subf+"permutation.txt")

# read key modification tables
pc1_table = read_table(subf+"pc-1.txt")
pc2_table = read_table(subf+"pc-2.txt")


# get or generate cleartext and key
cleartext = input("Paste the 64 binary digits for the cleartext, e.g. '0011 0100 ...': ")
if cleartext.strip()[0] not in [0, 1]:
    cleartext = generate_block(cleartext, 64)
    print("cleartext is:", cleartext)
else:
    cleartext.replace(" ", "")

k1 = (input("Paste the 48 binary digits for the key 'k1' for round 1, after key transformation, e.g. '0011 0100 ...': ")).replace(" ", "")
if k1.strip()[0] not in [0, 1]:
    if not k1.startswith('none'):
        k1 = generate_block(k1, 48)
        print("k1 is:", k1)
else:
    k1.replace(" ", "")

k = ""
if k1 == "none":
    k = (input("Paste the 64 binary digits for the key 'k' for round 1 which will be transformed to k1. insert e.g. '0011 0100 ...': ")).replace(" ", "")
    if k.strip()[0] not in [0, 1]:
        k = generate_block(k, 64)
        print("k is:", k)
    else:
        k.replace(" ", "")

# check inputs
if len(cleartext) != 64 or (len(k1) != 48 and k1 != "none") or (k1 == "none" and len(k) != 64):
    print("input did not have correct character length!")
    exit(1)

### pre-modify cleartext
# input permutation IP
ip = scramble(cleartext, ip_table)

l0 = str(ip)[:32]
r0 = str(ip)[32:]

print("L0 is:", as_blocks(l0, 4))
print("R0 is:", as_blocks(r0, 4))

if k1 == "none":
### pre-modify key
######
    # pc-1
    pc1_out = scramble(k, pc1_table)
    print(as_blocks(pc1_out, 4), "K after PC-1")
    c0 = pc1_out[:28]
    d0 = pc1_out[28:]
    # left shift
    c1 = c0[len(c0)-1:] + c0[:len(c0)-1]
    d1 = d0[len(d0)-1:] + d0[:len(d0)-1]
    # pc-2
    k1 = scramble(c1+d1, pc2_table)

### feistel function
######
# expansion
r0_out = scramble(r0, exp_table)
print(as_blocks(r0_out, 4), "R0 output after scrambling by expansion table:")
print(as_blocks(k1, 4), "K1")

# xor with key
sbox_input = (int(r0_out, 2) ^ int(k1, 2))
sbox_input = '{0:048b}'.format(sbox_input)
print("after XOR:")
print(as_blocks(sbox_input, 4))
sbox_input_blocks = as_blocks(sbox_input, 6).split()
print("same as input blocks for sboxes:")
print(sbox_input_blocks)

sbox_output_string = ""
for s in range(1, len(sbox_input_blocks)+1):
    block = sbox_input_blocks[s-1]
    print("block", block)
    col = int(block[1:5], 2)
    row = int(block[0]+block[5], 2)
    print("col:", col, "row", row)
    sbox_entry = sbox_tables[s-1][row][col]
    print("found value in sbox:", sbox_entry)
    sbox_entry_bin = '{0:04b}'.format(sbox_entry)
    print("sbox bin output:", sbox_entry_bin)
    sbox_output_string += sbox_entry_bin
print(as_blocks(sbox_output_string, 4), "= sbox output string")

# permutation
perm_output = permutation(sbox_output_string, perm_table)
print("perm output:")
print(as_blocks(perm_output, 4))

# final results
l1 = r0
r1 = '{0:032b}'.format((int(l0, 2) ^ int(perm_output, 2)))
print(as_blocks(l1, 4), "L1 (= R0)")
print(as_blocks(r1, 4), "R1")
